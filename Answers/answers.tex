% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
%\usepackage{geometry} % to change the page dimensions
% \geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=0in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options

\usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{logicproof}
\usepackage{tikz}
\usepackage{hyperref}
\usetikzlibrary{arrows,petri,topaths}
\usepackage{float}
\usepackage{graphicx}
\usepackage[T1]{fontenc}
\usepackage{listings}
\usepackage{pdflscape}
\lstset{
  basicstyle=\ttfamily,
  mathescape
}
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\sffamily\thepage\normalfont}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!
\newcommand{\qedsymbol}{\rightline{$\blacksquare$}}
\renewcommand{\familydefault}{\sfdefault}
\renewcommand{\thesection}{\hspace{-0.5cm}\arabic{section}}
\renewcommand{\thesubsection}{\alph{subsection})}
\renewcommand{\thesubsubsection}{}

\usepackage[style=numeric-comp]{biblatex}

%%% END Article customizations

%%% The "real" document content comes below...

\title{\vspace{-1.6cm}Bioinformatics Assignment}
\author{zrlr73}
\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section{Markov Models}
\subsection{HMMs with silent states}
Since the Viterbi algorithm is already popular for solving this problem without silent states, I decided to adapt it forthe inclusion of silent states. The Viterbi algorithm iterates using the observed output of the modelled HMM, constructing a trellis of possible states for each observed output. Since we need to cater for states that do not provide any output whatsoever, we need to be able to generate possible silent states as well as the existing trellis of non-silent states. We also need to consider these silent states alongside the non-silent ones when deciding on possible precursors for each observed outcome.

Therefore, I would propose the following modified Viterbi algorithm:
\begin{lstlisting}
Initialise trellis with $v_0(0)=1, v_k(0)=0\quad|\quad k>0$
Initialise 2D array of linked list heads with size $m\times L$

// For each observed output
For $i=1\text{ to }L$ do:
  // For each possible state
  For each state $l$ do:
    $v_l(i) = e_l(x_i) \times max_k\{v_k(i-1)\times m_{kl}\}$

  // Evaluate possible silent states
  Initialise array $a$ of linked list heads with length $m$ and $a_0=v_l$
  Initialise numeric array $b$ with length $m$
  Integer j = 0
  Initialise Boolean value $loop$
  Do:
    j++
    loop = false
    For each state $s$ do:
      $a_j(s) = e_s($silent$)\times max_f\{a_{j-1}(f)\times m_{fs}\}$

      if ($a_j(s) > v_l(s)$ and $a_j(s) > a_{j-1}(s)$):
        loop = true
  While (loop)

\end{lstlisting}

\subsection{The Expectation-Maximisation Algorithm}
My implementation of EM for HMMs (aka the Baum-Welch algorithm) has been included in the file 'q1b.py'. Expectation-Maximisation works as follows:

\begin{quote}
	Given the observed sequence, the alphabet, and the number of states, generate some arbitrary model parameters for the initial distribution of state likelihoods, transition probabilities and emission probabilities.
	
	Run the forward algorithm on the sequence, given the initial generated parameters. The forward algorithm generates a trellis of probabilities with width \texttt{num\_states} and height \texttt{sequence\_length}. Each probability in this trellis corresponds to the likelihood of being in each state at each point in the observed sequence.
	
	Run the backward algorithm on the sequence. The backward algorithm generates a similar trellis of probabilities to the forward algorithm: the only difference is that the probabilities in the trellis correspond to the likelihood of producing the rest of the sequence from the given state at the given point.
	
	With these metrics computed, we can compute the estimated number of times that each transition or emission will occur given our current model parameters. We can then divide these by the total number of transmissions \& emissions to find a new set of model parameters, and also compute a new distribution for the starting states. We also compute the likelihood of the sequence being observed under our new set of parameters.
	
	These new parameters are then substituted for the old ones, and the algorithm repeats again, starting with the forward algorithm. This happens until the likelihood of the new parameters stops appreciably increasing, at which point the algorithm terminates and returns the final set of parameters. I used the point at which two consecutive likelihoods are identical, since at this point the increase in likelihood is less than machine precision.
\end{quote}

Since we are multiplying lots of probabilities here, which tends to result in very small numbers and will never exceed 1.0, it is a good idea to work in log space in order to maximise precision and minimise underflows. Since the log function effectively 'stretches out' small numbers and 'squashes' large numbers in its output space, it is ideal for this task. In log space, operations such as multiplication and division can be easily done with addition and subtraction. Numbers do need to be converted out of log space for a 'logsumexp' operation when sums are required, but this is not a significant problem here.

One issue I did encounter was that there were instances where probabilities of 0 were required: this would land out of the range of the log function. To solve this, I implemented wrapper functions for \texttt{math.exp()} and \texttt{math.log()} which allowed the conversion of 0 into log space as negative infinity. Since the log space is entirely internal and the values returned are in conventional space, this works fine.

I also employed a scaling method to keep numbers within reasonable bounds, based on section (V)(A) of \href{http://dx.doi.org/10.1109/5.18626}{Rabiner's 1989 paper on HMMs}. This involved dividing each row in the forward trellis by its sum to ensure they added up to 1, and using the same forward sums to also scale the corresponding rows of the backward trellis. This causes the log likelihood in its normal form to be lost, but as shown in the paper it instead becomes equal to the sum of the logs of the row sums.

\subsubsection{Validation}


\hfill

\hfill


\section{Tree Reconstruction}

\subsection{The BUILD Algorithm}
If we call $(i,j)$ the lowest common ancestor of the leaves $i$ and $j$ of a tree, we can also define an operator $<$ which denotes the hierarchy of lowest common ancestors. For example, the constraint $(i,j)<(k,l)$ tells us that the lowest common ancestor of $k$ and $l$ is itself an ancestor of the lowest common ancestor of $i$ and $j$ - see figure below.

\begin{figure}
	\centering
	\includegraphics[width=10cm]{buildexample}
\end{figure}

The purpose of the BUILD algorithm is to construct a tree solely from these constraints. In a bioinformatics context, assuming the tree is a phylogeny, the constraints would be describing how closely related pairs of species are. As an example, we would specify the above constraint if we knew that the four species $\{i,j,k,l\}$ all had a common ancestor, but $i$ and $j$ were more closely related to each other than to the rest.

In BUILD, the structure of a tree is inferred using a technique known as 'partitioning'. This is when the set of leaves is split into groups known as 'blocks' at the root - for example, assuming descriptive enough constraints, the above tree would be split into the two sets $\{i,j,k\}$ and $\{l,m\}$. This partitioning can be done fairly easily using logical properties of the constraints:

From any constraint $(i,j)<(k,l)$ we can infer that:
\begin{enumerate}
	\item $i$ and $j$ are in the same block.
	\item If we already know that $k$ and $l$ are in the same block, then $i$ and $j$ must also be in that same block.
\end{enumerate}

We also assume that no two leaves are in the same block unless we can infer that they are from the constraints. In the original paper, this is the third rule.

With the set of leaves split into at least two blocks, we recurse into each block, partitioning every block until there is only one leaf left in the set. At this point, the algorithm's recursive structure exactly reflects the tree being constructed, so it simply needs to construct and return a tree. Instances with just one leaf return it, and instances that partitioned items join the returned structures with a new node until the outer layer is reached and the tree is complete.


\subsection{Partitioning}
Partitioning could occur as follows:
\begin{lstlisting}
// a 2D array: items in this array will be referred to as 'blocks'
$\pi_C$ = []

For each constraint $(a,b)<(c,d)$:
  If neither $a$ nor $b$ already exists in $\pi_C$:
    Add the new block [$a$,$b$] to $\pi_C$

  Else if $a$ and $b$ already exist in separate blocks in $\pi_C$:
    Replace those two blocks with their union

  Else if $a$ already exists in a block in $\pi_C$:
    Add $b$ to that block
  Else if $b$ already exists in a block in $\pi_C$:
    Add $a$ to that block

For each constraint $(a,b)<(c,d)$:
  If $c$ and $d$ share a block, merge the block containing $a$ and $b$ into it

For each leaf $x$ that is not a member of an existing block:
  Add the new block [$x$] to $\pi_C$
\end{lstlisting}

The result of this algorithm is the 2D array $\pi_C$, with structure as follows:
\begin{lstlisting}
[
  [i, j, k],
  [l, m, o],
  [n]
]
\end{lstlisting}
Each sub-array (each depicted here on its own line) corresponds to a block $S_i$, with letters denoting the leaves in that block.


\subsection{Example}
For clarity, I have named each block and set of constraints with their recursion depth and an arbitrary number to identify them at that depth. This is notated $S_\text{number}^\text{depth}$.

\setcounter{subsubsection}{-1}
\renewcommand{\thesubsubsection}{Recursion depth \arabic{subsubsection}}

\subsubsection{}
	\begin{center}
	Generating blocks from first halves of constraints:
	
	\begin{tabular}{c c c c}
		\{e,f\} & \{c,h,a,j,n,l\} & \{d,i,g,b\} & \{k,m\}
	\end{tabular}
	
	Consolidating blocks with second halves of constraints:
	
	\begin{tabular}{c c c}
		\hspace{0.8cm}$S_1^1$\hspace{0.8cm} & \hspace{0.8cm}$S_2^1$\hspace{0.8cm} & \hspace{0.8cm}$S_3^1$\hspace{0.8cm} \\
		\{e,f,c,h,a,j,n,l\} & \{d,i,g,b\} & \{k,m\}
	\end{tabular}
	
	Finding constraints for each block:
	
	\begin{tabular}{c c c}
		\hspace{0.8cm}$C_1^1$\hspace{0.8cm} & \hspace{0.8cm}$C_2^1$\hspace{0.8cm} & \hspace{0.8cm}$C_3^1$\hspace{0.8cm} \\
		$(c,h)<(a,n)$ & $(d,i)<(g,i)$ & $\emptyset$ \\
		$(j,n)<(j,l)$ & $(g,b)<(g,i)$ \\
		$(c,a)<(f,h)$ \\
		$(j,l)<(e,n)$ \\
		$(n,l)<(a,f)$ \\
		$(c,h)<(c,a)$ \\
		$(e,f)<(h,l)$ \\
		$(j,l)<(j,a)$ \\
		$(j,n)<(j,f)$ \\
	\end{tabular}

	Recursion:
	
	\begin{tabular}{c c c c c}
		 & Block & & Constraints & \\
		BUILD( & $S_1^1$ & , & $C_1^1$ & ) \\
		BUILD( & $S_2^1$ & , & $C_2^1$ & ) \\
		BUILD( & $S_3^1$ & , & $C_3^1$ & )
	\end{tabular}
	\end{center}


\subsubsection{}

	\hspace{0.5cm}BUILD($S_1^1$, $C_1^1$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$S_1^2$\hspace{0.8cm} & \hspace{0.8cm}$S_2^2$\hspace{0.8cm} & \hspace{0.8cm}$S_3^2$\hspace{0.8cm} \\
			\{c,h,a\} & \{j,n,l\} & \{e,f\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_1^2$\hspace{0.8cm} & \hspace{0.8cm}$C_2^2$\hspace{0.8cm} & \hspace{0.8cm}$C_3^2$\hspace{0.8cm} \\
			$(c,h)<(c,a)$ & $(j,n)<(j,l)$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_1^2$ & , & $C_1^2$ & ) \\
			BUILD( & $S_2^2$ & , & $C_2^2$ & ) \\
			BUILD( & $S_3^2$ & , & $C_3^2$ & )
		\end{tabular}
		\end{center}


	\hspace{0.5cm}BUILD($S_2^1$, $C_2^1$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_4^2$\hspace{0.8cm} & \hspace{0.8cm}$S_5^2$\hspace{0.8cm} \\
			\{d,i\} & \{g,b\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_4^2$\hspace{0.8cm} & \hspace{0.8cm}$C_5^2$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_4^2$ & , & $C_4^2$ & ) \\
			BUILD( & $S_5^2$ & , & $C_5^2$ & )
		\end{tabular}
		\end{center}


	\hspace{0.5cm}BUILD($S_3^1$, $C_3^1$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_6^2$\hspace{0.8cm} & \hspace{0.8cm}$S_7^2$\hspace{0.8cm} \\
			\{k\} & \{m\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_6^2$\hspace{0.8cm} & \hspace{0.8cm}$C_7^2$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_6^2$ & , & $C_6^2$ & ) \\
			BUILD( & $S_7^2$ & , & $C_7^2$ & )
		\end{tabular}
		\end{center}


\subsubsection{}

	\hspace{0.5cm}BUILD($S_1^2$, $C_1^2$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_1^3$\hspace{0.8cm} & \hspace{0.8cm}$S_2^3$\hspace{0.8cm} \\
			\{c,h\} & \{a\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_1^3$\hspace{0.8cm} & \hspace{0.8cm}$C_2^3$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_1^3$ & , & $C_1^3$ & ) \\
			BUILD( & $S_2^3$ & , & $C_2^3$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_2^2$, $C_2^2$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_3^3$\hspace{0.8cm} & \hspace{0.8cm}$S_4^3$\hspace{0.8cm} \\
			\{j,n\} & \{l\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_3^3$\hspace{0.8cm} & \hspace{0.8cm}$C_4^3$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_3^3$ & , & $C_3^3$ & ) \\
			BUILD( & $S_4^3$ & , & $C_4^3$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_3^2$, $C_3^2$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_5^3$\hspace{0.8cm} & \hspace{0.8cm}$S_6^3$\hspace{0.8cm} \\
			\{e\} & \{f\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_5^3$\hspace{0.8cm} & \hspace{0.8cm}$C_6^3$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_5^3$ & , & $C_5^3$ & ) \\
			BUILD( & $S_6^3$ & , & $C_6^3$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_4^2$, $C_4^2$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_7^3$\hspace{0.8cm} & \hspace{0.8cm}$S_8^3$\hspace{0.8cm} \\
			\{d\} & \{i\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_7^3$\hspace{0.8cm} & \hspace{0.8cm}$C_8^3$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_7^3$ & , & $C_7^3$ & ) \\
			BUILD( & $S_8^3$ & , & $C_8^3$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_5^2$, $C_5^2$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_9^3$\hspace{0.8cm} & \hspace{0.8cm}$S_{10}^3$\hspace{0.8cm} \\
			\{g\} & \{b\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_9^3$\hspace{0.8cm} & \hspace{0.8cm}$C_{10}^3$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_9^3$ & , & $C_9^3$ & ) \\
			BUILD( & $S_{10}^3$ & , & $C_{10}^3$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_6^2$, $C_6^2$):
		\begin{center}
		Return k
		\end{center}

	\hspace{0.5cm}BUILD($S_7^2$, $C_7^2$):
		\begin{center}
		Return m
		\end{center}


\subsubsection{}

	\hspace{0.5cm}BUILD($S_1^3$, $C_1^3$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_1^4$\hspace{0.8cm} & \hspace{0.8cm}$S_2^4$\hspace{0.8cm} \\
			\{c\} & \{h\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_1^4$\hspace{0.8cm} & \hspace{0.8cm}$C_2^4$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_1^4$ & , & $C_1^4$ & ) \\
			BUILD( & $S_2^4$ & , & $C_2^4$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_2^3$, $C_2^3$):
		\begin{center}
		Return a
		\end{center}

	\hspace{0.5cm}BUILD($S_3^3$, $C_3^3$):
		\begin{center}
		Generating \& consolidating blocks from constraints:
		
		\begin{tabular}{c c}
			\hspace{0.8cm}$S_1^4$\hspace{0.8cm} & \hspace{0.8cm}$S_2^4$\hspace{0.8cm} \\
			\{j\} & \{n\}
		\end{tabular}
	
		Finding constraints for each block:
		
		\begin{tabular}{c c c}
			\hspace{0.8cm}$C_3^4$\hspace{0.8cm} & \hspace{0.8cm}$C_4^4$\hspace{0.8cm} \\
			$\emptyset$ & $\emptyset$
		\end{tabular}

		Recursion:
		
		\begin{tabular}{c c c c c}
			 & Block & & Constraints & \\
			BUILD( & $S_3^4$ & , & $C_3^4$ & ) \\
			BUILD( & $S_4^4$ & , & $C_4^4$ & )
		\end{tabular}
		\end{center}

	\hspace{0.5cm}BUILD($S_4^3$, $C_4^3$):
		\begin{center}
		Return l
		\end{center}

	\hspace{0.5cm}BUILD($S_5^3$, $C_5^3$):
		\begin{center}
		Return e
		\end{center}

	\hspace{0.5cm}BUILD($S_6^3$, $C_6^3$):
		\begin{center}
		Return f
		\end{center}

	\hspace{0.5cm}BUILD($S_7^3$, $C_7^3$):
		\begin{center}
		Return d
		\end{center}

	\hspace{0.5cm}BUILD($S_8^3$, $C_8^3$):
		\begin{center}
		Return i
		\end{center}

	\hspace{0.5cm}BUILD($S_9^3$, $C_9^3$):
		\begin{center}
		Return g
		\end{center}

	\hspace{0.5cm}BUILD($S_{10}^3$, $C_{10}^3$):
		\begin{center}
		Return b
		\end{center}


\subsubsection{}

	\hspace{0.5cm}BUILD($S_1^4$, $C_1^4$):
		\begin{center}
		Return c
		\end{center}

	\hspace{0.5cm}BUILD($S_2^4$, $C_2^4$):
		\begin{center}
		Return h
		\end{center}

	\hspace{0.5cm}BUILD($S_3^4$, $C_3^4$):
		\begin{center}
		Return j
		\end{center}

	\hspace{0.5cm}BUILD($S_4^4$, $C_4^4$):
		\begin{center}
		Return n
		\end{center}

Travelling back up the recursion tree, with each internal node represented as a new set containing its children:

\setcounter{subsubsection}{3}
\subsubsection{}
	\begin{center}
	\begin{tabular}{c c}
		Call & Returned Value \\
		BUILD($S_1^4$, $C_1^4$) & c \\
		BUILD($S_2^4$, $C_2^4$) & h \\
		BUILD($S_3^4$, $C_3^4$) & j \\
		BUILD($S_4^4$, $C_4^4$) & n
	\end{tabular}
	\end{center}

\setcounter{subsubsection}{2}
\subsubsection{}
	\begin{center}
	\begin{tabular}{c c}
		Call & Returned Value \\
		BUILD($S_1^3$, $C_1^3$) & \{c, h\} \\
		BUILD($S_2^3$, $C_2^3$) & a \\
		BUILD($S_3^3$, $C_3^3$) & \{j, n\} \\
		BUILD($S_4^3$, $C_4^3$) & l \\
		BUILD($S_5^3$, $C_5^3$) & e \\
		BUILD($S_6^3$, $C_6^3$) & f \\
		BUILD($S_7^3$, $C_7^3$) & d \\
		BUILD($S_8^3$, $C_8^3$) & i \\
		BUILD($S_9^3$, $C_9^3$) & g \\
		BUILD($S_{10}^3$, $C_{10}^3$) & b
	\end{tabular}
	\end{center}

\setcounter{subsubsection}{1}
\subsubsection{}
	\begin{center}
	\begin{tabular}{c c}
		Call & Returned Value \\
		BUILD($S_1^2$, $C_1^2$) & \{\{c, h\}, a\} \\
		BUILD($S_2^2$, $C_2^2$) & \{\{j, n\}, l\} \\
		BUILD($S_3^2$, $C_3^2$) & \{e, f\} \\
		BUILD($S_4^2$, $C_4^2$) & \{d, i\} \\
		BUILD($S_5^2$, $C_5^2$) & \{g, b\} \\
		BUILD($S_6^2$, $C_6^2$) & k \\
		BUILD($S_7^2$, $C_7^2$) & m
	\end{tabular}
	\end{center}

\setcounter{subsubsection}{0}
\subsubsection{}
	\begin{center}
	\begin{tabular}{c c}
		Call & Returned Value \\
		BUILD($S_1^2$, $C_1^2$) & \{\{\{c, h\}, a\}, \{\{j, n\}, l\}, \{e, f\}\} \\
		BUILD($S_2^2$, $C_2^2$) & \{\{d, i\}, \{g, b\}\} \\
		BUILD($S_3^2$, $C_3^2$) & \{k, m\}
	\end{tabular}
	\end{center}

\setcounter{subsubsection}{-1}
\subsubsection{}
	\begin{center}
	\begin{tabular}{c c}
		Call & Returned Value \\
		BUILD($S$, $C$) & \{\{\{\{c, h\}, a\}, \{\{j, n\}, l\}, \{e, f\}\}, \{\{d, i\}, \{g, b\}\}, \{k, m\}\} \\
	\end{tabular}
	\end{center}


\hfill


\hfill


To summarise, the below tree is constructed:

\includegraphics[width=\textwidth]{buildrun}
\renewcommand{\thesubsubsection}{}


\begin{landscape}
\subsection{Reversing BUILD}
This algorithm has been implemented in Python 3.9 (specifically, 3.9.2), and is also included as 'q2d.py' alongside this PDF.
\begin{lstlisting}
class Constraint:
  """Class representing a tree constraint such as those used by the BUILD algorithm.
  Stored constraint becomes (a, b) < (c, d) where a, b, c, d are the four arguments provided.
  Access Constraint.text to get the constraint as a human-readable string.
  """

  def __init__(self, a: str, b: str, c: str, d:str):
    self.items = [a, b, c, d]
    self.text = f'({a}, {b}) < ({c}, {d})'


class TreeNode:
  """Class representing a node in a tree. Takes two arguments:
  - children: A list of TreeNodes representing children (provide [] for a leaf)
  - name: The node's name (required for a leaf, optional otherwise)
  """

  def __init__(self, children: list, name: str = ''):
    self.children = children
    self.name = name
    self.isLeaf = children == []
  
  def traverse(self) -> (list, list, list):
    """Returns three values in a tuple:
    - A list of constraints representing the subtree below the current node
    - A 'flattened' list of the named nodes beneath the current node in the tree
      ie, a node with children (a node connected to (a, b), c) would return [a, b, c]
    - A list of pairs of nodes that would need to be linked together by constraints created
      by any parent of the current node
    """

    # Leaves return just themselves
    if (self.isLeaf):
      return ([], [self.name], [])
    
    numChildren = len(self.children)


    # Traverse children
    leaves = []
    internals = []

    childFlatLists = []
    constraintLists = []

    for i in self.children:
      (constraints, flatList, pairsToConnect) = i.traverse()

      if (len(flatList) == 1):
        leaves.append(flatList[0])
      
      else:
        internals.append((constraints, flatList, pairsToConnect))
        childFlatLists.append(flatList)
        constraintLists.append(constraints)

    numLeaves = len(leaves)
    numInternals = len(internals)


    # Generate constraints from data returned by children
    myConstraints = []
    myFlatList = leaves
    myPairsToConnect = []
    childPairsToConnect = []

    # If we're only connected to leaves, just return the flattened list of leaves,
    #   making sure the parent connects them
    if (numInternals == 0):
      return ([], leaves, [(leaves[i], leaves[i+1]) for i in range(numLeaves-1)])

    # If there are multiple internal children, link them all with constraints
    elif (numInternals > 1):
      # As we are connecting two internal children at a time, making one constrant for
      #   each would result in an unnecessary 'loop' - therefore we can omit one
      for i in range(numInternals-1):
        
        # Generate constraint, adding the right hand side to the list of pairs to connect for any parent
        thisFlatList = internals[i][1]
        nextFlatList = internals[i+1][1]
        myPairsToConnect.append((thisFlatList[0], nextFlatList[0]))

        # Add any remaining pairsToConnect from the current internal to a central list
        childPairsToConnect.extend(internals[i][2])
    
    # Add pairsToConnect for any children not covered above
    #   (either a single internal child skipped by the if, or the final one which was not covered by the loop)
    childPairsToConnect.extend(internals[numInternals-1][2])
    
    # Link any leaves to an internal
    # (If we've got this far without returning, we have at least one internal child)
    firstFlatList = internals[0][1]
    for i in leaves:
      # If we have pairsToConnect from internal children, use those
      if (len(childPairsToConnect) > 0):
        connectingPair = childPairsToConnect.pop(0)
      
      else:
        # Otherwise, just use the first two leaves in the first internal
        connectingPair = firstFlatList
      
      # Generate constraint, adding the right hand side to the list of pairs to connect for any parent
      myConstraints.append(Constraint(connectingPair[0], connectingPair[1], connectingPair[0], i))
      myPairsToConnect.append((connectingPair[0], i))
    
    # If there are any more pairsToConnect from children
    while (len(childPairsToConnect) > 0):
      toConnect = childPairsToConnect.pop(0)

      # If we have any leaves, just connect to the first one
      if (numLeaves != 0):
        toConnectTo = leaves[0]
      
      else:
        # Otherwise, find a pair from any internal that doesn't include the pair we're connecting
        # There will always be at least two children in a valid tree, so
        #   if there are no leaves there will be enough internals
        toConnectTo = next(
          flatList[0]
          for flatList in childFlatLists
          if ((toConnect[0] not in flatList) and (toConnect[1] not in flatList))
        )
      
      # Generate the constraint
      #   (no need to add to myPairsToConnect as the right hand side is superfluous)
      myConstraints.append(Constraint(toConnect[0], toConnect[1], toConnect[0], toConnectTo))
    
    # Prepare output & return
    for i in childFlatLists:
      myFlatList.extend(i)
    
    for i in constraintLists:
      myConstraints.extend(i)

    return (myConstraints, myFlatList, myPairsToConnect)
  
  def getConstraints(self):
    """Returns a list of constraints representing the (sub)tree under the current node
    (Executes traverse() and returns only the constraints)
    """

    return self.traverse()[0]
\end{lstlisting}
\end{landscape}

\subsubsection{Proof of correctness}
The key to this algorithm is the \texttt{TreeNode.traverse()} function. This function returns three things:
\begin{itemize}
	\item A list of constraints defining the subtree under the current node
	\item A 'flattened' list of all the leaves beneath the current node
	\item A list of pairs of leaves that occupy different branches underneath the current node (such that those branches will need to be connected up in the parent to ensure that they are all passed down to the current node when constructing)
\end{itemize}

The \texttt{TreeNode.traverse()} function calls itself recursively on the children, and uses the output of each child to construct the information needed for the current node. Each child is treated as a 'black box' that generates the constraints needed to describe its own structure and returns any pairs of nodes that need connecting together to form a coherent block at the parent level. As such, as long as it generates correct constraints for shallow (< $\approx$3-4-layer) trees, it will be correct for any tree.

The constraints returned are decided as follows:
\begin{itemize}
	\item No constraints if the current node has no internal children
	\item One for each leaf 'l': (a, b) < (a, l) where [a, b] come from the same internal child (and willl be preferentially selected from child pairsToConnect sets before arbitrarily picking them)
	\item Any further constraints (a, b) < (a, x) where [a, b] are from child pairsToConnect sets (these simply serve to merge blocks in order to generate those corresponding to internal children)
	\item Any constraints passed up from children
\end{itemize}

The flattened list is a simple list of all leaves below the current node - defined recursively, it's [a] for any leaf a and the union of all children's flattened lists for all internal nodes.

The pairsToConnect are decided as follows:
\begin{itemize}
	\item No pairs if the current node is a leaf
	\item (n$_i$, n$_{i+1}$) for each internal node n$_i$ except the last
	\item (a, l) for each leaf l where a is a leaf beneath an internal child
\end{itemize}
Abstractly, every branch underneath the current node is linked to at least one other branch, forming a minimal fully connected group. 

For the following structures, \texttt{TreeNode.traverse()} on the root might return:
\begin{center}
\begin{tabular}{>{\centering}m{0.45\textwidth} >{\centering\arraybackslash}m{0.5\textwidth}}
	\includegraphics[scale=0.2]{traverse1} & ([], ['a'], []) \\
	\multicolumn{2}{l}{\parbox{\textwidth}{This is a trivial case and contains just one leaf. As such it returns no constraints or pairs to connect; simply itself inside the flattened child list.}}
\end{tabular}
\begin{tabular}{>{\centering}m{0.45\textwidth} >{\centering\arraybackslash}m{0.55\textwidth}}
	\includegraphics[scale=0.1]{traverse2} & ([], ['a', 'b', ..., 'z'], [('a', 'b'), ('b', 'c'), ..., ('y', 'z')]) \\
	\multicolumn{2}{l}{\parbox{\textwidth}{This case demonstrates how an internal node with leaves for children would return itself. It still generates no constraints. This is correct: it is impossible to correctly describe a tree of this structure with constraints of the format used here.}}
\end{tabular}
\begin{tabular}{>{\centering}m{0.45\textwidth} >{\centering\arraybackslash}m{0.5\textwidth}}
	\includegraphics[scale=0.1]{traverse3} & (['(a, b) < (a, c)'], ['a', 'b', 'c'], [('a', 'c')]) \\
	\multicolumn{2}{l}{\parbox{\textwidth}{This is the simplest tree for which a constraint can be generated. It is represented by a single constraint. At this level we cannot generate constraints that ensure that the items of the (a, b) branch and the (c) branch are put together in the parent's blocks, which is why it returns the pair (a, c) for connecting with a constraint LHS in the parent.}}
\end{tabular}
\begin{tabular}{>{\centering}m{0.45\textwidth} >{\centering\arraybackslash}m{0.5\textwidth}}
	\includegraphics[scale=0.1]{traverse4} & (['(a, b) < (a, i)', '(i, j) < (i, s)', '(s, t) < (s, a)'], ['a', 'b', 'i', 'j', 's', 't'], [('a', 'i'), ('i', 's')]) \\
	\multicolumn{2}{l}{\parbox{\textwidth}{Each of the nodes in the middle layer has instructed the root here to join their leaves into one block, which is done with each constraint returned here. The internal nodes' sets will not be joined by the parent as things stand here though, so pairs of single leaves from each one are returned to the parent for connecting at the next layer.}}
\end{tabular}
\begin{tabular}{>{\centering}m{0.45\textwidth} >{\centering\arraybackslash}m{0.55\textwidth}}
	\includegraphics[scale=0.1]{traverse5} & (['(a, b) < (a, s)', '(i, j) < (i, t)'], ['a', 'b', 'i', 'j', 's', 't'], [('a', 'i'), ('i', 's'), ('a', 't')]) \\
	\multicolumn{2}{l}{\parbox{\textwidth}{This is a larger version of the third example. Each constraint links an internal node to a leaf, and serves two purposes: to define internal children's blocks and to state the existence of leaves. Returned for connection by the parent are pairs of single nodes from each child.}}
\end{tabular}
\end{center}

While I have not conducted any formal proofs, I am confident that this algorithm is close to being optimal (if not optimal already). As a benchmark, it describes the graph in question 2c above in only 11 constraints. For most small, contrived graphs, I believe its result to be accurate, and see no particular reason that this would not apply to larger graphs too.

\end{document}
